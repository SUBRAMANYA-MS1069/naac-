{'role': 'assistant', 'content': 'Let\'s continue creating more services:\n\n<function_calls>\n<create-file file_path="src/services/expenditure/purchaseOrderService.js">\nconst PurchaseOrder = require(\'../../models/expenditure/PurchaseOrder\');\nconst Vendor = require(\'../../models/expenditure/Vendor\');\nconst { AppError } = require(\'../../utils/helpers/errorHelper\');\n\n/**\n * Create a new purchase order\n * @param {Object} poData - Purchase order data\n * @param {String} tenantId - Tenant ID\n * @param {String} userId - User ID\n * @returns {Object} Created purchase order\n */\nconst createPurchaseOrder = async (poData, tenantId, userId) => {\n  try {\n    // Add tenantId and preparedBy to PO data\n    poData.tenantId = tenantId;\n    poData.preparedBy = userId;\n    \n    // Check if vendor exists and is active\n    const vendor = await Vendor.findOne({ \n      vendorId: poData.vendorId, \n      tenantId,\n      isActive: true \n    });\n    \n    if (!vendor) {\n      throw new AppError(\'Vendor not found or inactive\', 404, \'VENDOR_NOT_FOUND\');\n    }\n    \n    // Calculate totals\n    let subtotal = 0;\n    let taxTotal = 0;\n    \n    for (const item of poData.items) {\n      const itemTotal = item.quantity * item.unitPrice;\n      const itemTax = itemTotal * (item.taxRate / 100);\n      \n      item.totalAmount = itemTotal + itemTax;\n      subtotal += itemTotal;\n      taxTotal += itemTax;\n    }\n    \n    poData.subtotal = subtotal;\n    poData.taxTotal = taxTotal;\n    poData.totalAmount = subtotal + taxTotal + (poData.shippingCharges || 0);\n    \n    // Create purchase order\n    const purchaseOrder = new PurchaseOrder(poData);\n    await purchaseOrder.save();\n    \n    return purchaseOrder;\n  } catch (error) {\n    if (error.code === 11000) {\n      throw new AppError(\'Purchase order with this number already exists\', 409, \'DUPLICATE_PO\');\n    }\n    throw error;\n  }\n};\n\n/**\n * Get purchase orders with filters\n * @param {Object} filters - Filter criteria\n * @param {Object} pagination - Pagination options\n * @param {String} tenantId - Tenant ID\n * @returns {Object} Purchase orders and pagination info\n */\nconst getPurchaseOrders = async (filters, pagination, tenantId) => {\n  try {\n    const query = { tenantId, ...filters };\n    \n    // Handle vendor filter\n    if (filters.vendorId) {\n      query.vendorId = filters.vendorId;\n    }\n    \n    // Handle status filter\n    if (filters.status) {\n      query.status = filters.status;\n    }\n    \n    // Handle date range filter\n    if (filters.startDate || filters.endDate) {\n      query.poDate = {};\n      if (filters.startDate) {\n        query.poDate.$gte = new Date(filters.startDate);\n      }\n      if (filters.endDate) {\n        query.poDate.$lte = new Date(filters.endDate);\n      }\n    }\n    \n    const purchaseOrders = await PurchaseOrder.find(query)\n      .sort(pagination.sort || \'-poDate\')\n      .skip(pagination.skip)\n      .limit(pagination.limit)\n      .populate(\'vendorId\', \'vendorName vendorCode\')\n      .populate(\'preparedBy\', \'name email\');\n    \n    const total = await PurchaseOrder.countDocuments(query);\n    \n    return {\n      purchaseOrders,\n      total,\n      page: pagination.page,\n      limit: pagination.limit\n    };\n  } catch (error) {\n    throw new AppError(\'Failed to fetch purchase orders\', 500, \'FETCH_POS_ERROR\');\n  }\n};\n\n/**\n * Get purchase order by ID\n * @param {String} poId - Purchase order ID\n * @param {String} tenantId - Tenant ID\n * @returns {Object} Purchase order\n */\nconst getPurchaseOrderById = async (poId, tenantId) => {\n  try {\n    const purchaseOrder = await PurchaseOrder.findOne({ poId, tenantId })\n      .populate(\'vendorId\', \'vendorName vendorCode contactPerson address\')\n      .populate(\'preparedBy\', \'name email\')\n      .populate(\'approvers.userId\', \'name email\');\n    \n    if (!purchaseOrder) {\n      throw new AppError(\'Purchase order not found\', 404, \'PO_NOT_FOUND\');\n    }\n    \n    return purchaseOrder;\n  } catch (error) {\n    if (error.name === \'CastError\') {\n      throw new AppError(\'Invalid purchase order ID\', 400, \'INVALID_PO_ID\');\n    }\n    throw error;\n  }\n};\n\n/**\n * Update purchase order\n * @param {String} poId - Purchase order ID\n * @param {Object} updateData - Update data\n * @param {String} tenantId - Tenant ID\n * @returns {Object} Updated purchase order\n */\nconst updatePurchaseOrder = async (poId, updateData, tenantId) => {\n  try {\n    // Prevent updating closed or cancelled POs\n    const existingPO = await PurchaseOrder.findOne({ poId, tenantId });\n    \n    if (!existingPO) {\n      throw new AppError(\'Purchase order not found\', 404, \'PO_NOT_FOUND\');\n    }\n    \n    if ([\'Closed\', \'Cancelled\'].includes(existingPO.status)) {\n      throw new AppError(\'Cannot update closed or cancelled purchase order\', 400, \'CANNOT_UPDATE_CLOSED_PO\');\n    }\n    \n    // Recalculate totals if items are updated\n    if (updateData.items) {\n      let subtotal = 0;\n      let taxTotal = 0;\n      \n      for (const item of updateData.items) {\n        const itemTotal = item.quantity * item.unitPrice;\n        const itemTax = itemTotal * (item.taxRate / 100);\n        \n        item.totalAmount = itemTotal + itemTax;\n        subtotal += itemTotal;\n        taxTotal += itemTax;\n      }\n      \n      updateData.subtotal = subtotal;\n      updateData.taxTotal = taxTotal;\n      updateData.totalAmount = subtotal + taxTotal + (updateData.shippingCharges || 0);\n    }\n    \n    const purchaseOrder = await PurchaseOrder.findOneAndUpdate(\n      { poId, tenantId },\n      updateData,\n      { new: true, runValidators: true }\n    );\n    \n    return purchaseOrder;\n  } catch (error) {\n    if (error.name === \'CastError\') {\n      throw new AppError(\'Invalid purchase order ID\', 400, \'INVALID_PO_ID\');\n    }\n    throw error;\n  }\n};\n\n/**\n * Approve purchase order\n * @param {String} poId - Purchase order ID\n * @param {String} tenantId - Tenant ID\n * @param {String} userId - User ID\n * @param {String} comments - Approval comments\n * @returns {Object} Approved purchase order\n */\nconst approvePurchaseOrder = async (poId, tenantId, userId, comments) => {\n  try {\n    const purchaseOrder = await PurchaseOrder.findOne({ poId, tenantId });\n    \n    if (!purchaseOrder) {\n      throw new AppError(\'Purchase order not found\', 404, \'PO_NOT_FOUND\');\n    }\n    \n    if (purchaseOrder.status !== \'PendingApproval\') {\n      throw new AppError(\'Purchase order is not in pending approval status\', 400, \'INVALID_PO_STATUS\');\n    }\n    \n    // Add approver to the list\n    purchaseOrder.approvers.push({\n      userId,\n      approved: true,\n      approvedDate: new Date(),\n      comments\n    });\n    \n    // Check if all required approvals are done\n    // In a real implementation, you would check against approval workflow\n    purchaseOrder.status = \'Approved\';\n    \n    await purchaseOrder.save();\n    \n    return purchaseOrder;\n  } catch (error) {\n    if (error.name === \'CastError\') {\n      throw new AppError(\'Invalid purchase order ID\', 400, \'INVALID_PO_ID\');\n    }\n    throw error;\n  }\n};\n\n/**\n * Close purchase order\n * @param {String} poId - Purchase order ID\n * @param {String} tenantId - Tenant ID\n * @param {String} userId - User ID\n * @param {String} reason - Closure reason\n * @returns {Object} Closed purchase order\n */\nconst closePurchaseOrder = async (poId, tenantId, userId, reason) => {\n  try {\n    const purchaseOrder = await PurchaseOrder.findOne({ poId, tenantId });\n    \n    if (!purchaseOrder) {\n      throw new AppError(\'Purchase order not found\', 404, \'PO_NOT_FOUND\');\n    }\n    \n    if (purchaseOrder.status === \'Closed\') {\n      throw new AppError(\'Purchase order is already closed\', 400, \'PO_ALREADY_CLOSED\');\n    }\n    \n    purchaseOrder.status = \'Closed\';\n    purchaseOrder.closedDate = new Date();\n    purchaseOrder.closedBy = userId;\n    purchaseOrder.closureReason = reason;\n    \n    await purchaseOrder.save();\n    \n    return purchaseOrder;\n  } catch (error) {\n    if (error.name === \'CastError\') {\n      throw new AppError(\'Invalid purchase order ID\', 400, \'INVALID_PO_ID\');\n    }\n    throw error;\n  }\n};\n\nmodule.exports = {\n  createPurchaseOrder,\n  getPurchaseOrders,\n  getPurchaseOrderById,\n  updatePurchaseOrder,\n  approvePurchaseOrder,\n  closePurchaseOrder\n};\n</create-file>\n</function_calls>'}