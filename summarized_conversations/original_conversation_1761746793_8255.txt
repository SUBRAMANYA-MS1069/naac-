{'role': 'assistant', 'content': 'Let\'s continue creating more services:\n\n<function_calls>\n<create-file file_path="src/services/fees/invoiceService.js">\nconst FeeInvoice = require(\'../../models/fees/FeeInvoice\');\nconst FeeStructure = require(\'../../models/fees/FeeStructure\');\nconst { AppError } = require(\'../../utils/helpers/errorHelper\');\nconst { calculateTotalDeductions } = require(\'../../utils/calculators/salaryCalculator\');\n\n/**\n * Generate fee invoice\n * @param {Object} invoiceData - Invoice data\n * @param {String} tenantId - Tenant ID\n * @returns {Object} Created invoice\n */\nconst generateInvoice = async (invoiceData, tenantId) => {\n  try {\n    // Add tenantId to invoice data\n    invoiceData.tenantId = tenantId;\n    \n    // Get fee structure\n    const feeStructure = await FeeStructure.findOne({ \n      feeStructureId: invoiceData.feeStructureId, \n      tenantId,\n      isActive: true \n    });\n    \n    if (!feeStructure) {\n      throw new AppError(\'Fee structure not found or inactive\', 404, \'FEE_STRUCTURE_NOT_FOUND\');\n    }\n    \n    // Set invoice details from fee structure\n    invoiceData.totalAmount = feeStructure.totalFee;\n    invoiceData.finalAmount = feeStructure.totalFee;\n    \n    // Apply discounts if any\n    if (invoiceData.discountsApplied && invoiceData.discountsApplied.length > 0) {\n      let totalDiscount = 0;\n      \n      for (const discount of invoiceData.discountsApplied) {\n        // In a real implementation, you would validate discount eligibility\n        totalDiscount += discount.discountAmount;\n      }\n      \n      invoiceData.finalAmount = invoiceData.totalAmount - totalDiscount;\n    }\n    \n    // Apply adjustments if any\n    if (invoiceData.adjustments && invoiceData.adjustments.length > 0) {\n      let totalAdjustment = 0;\n      \n      for (const adjustment of invoiceData.adjustments) {\n        totalAdjustment += adjustment.amount;\n      }\n      \n      invoiceData.finalAmount += totalAdjustment;\n    }\n    \n    // Ensure final amount is not negative\n    invoiceData.finalAmount = Math.max(0, invoiceData.finalAmount);\n    invoiceData.balanceAmount = invoiceData.finalAmount;\n    \n    // Create invoice\n    const invoice = new FeeInvoice(invoiceData);\n    await invoice.save();\n    \n    return invoice;\n  } catch (error) {\n    if (error.code === 11000) {\n      throw new AppError(\'Invoice with this number already exists\', 409, \'DUPLICATE_INVOICE\');\n    }\n    throw error;\n  }\n};\n\n/**\n * Get invoices with filters\n * @param {Object} filters - Filter criteria\n * @param {Object} pagination - Pagination options\n * @param {String} tenantId - Tenant ID\n * @returns {Object} Invoices and pagination info\n */\nconst getInvoices = async (filters, pagination, tenantId) => {\n  try {\n    const query = { tenantId, ...filters };\n    \n    // Handle student filter\n    if (filters.studentId) {\n      query.studentId = filters.studentId;\n    }\n    \n    // Handle academic year filter\n    if (filters.academicYear) {\n      query.academicYear = filters.academicYear;\n    }\n    \n    // Handle status filter\n    if (filters.status) {\n      query.status = filters.status;\n    }\n    \n    // Handle date range filter\n    if (filters.startDate || filters.endDate) {\n      query.dueDate = {};\n      if (filters.startDate) {\n        query.dueDate.$gte = new Date(filters.startDate);\n      }\n      if (filters.endDate) {\n        query.dueDate.$lte = new Date(filters.endDate);\n      }\n    }\n    \n    const invoices = await FeeInvoice.find(query)\n      .sort(pagination.sort || \'-createdAt\')\n      .skip(pagination.skip)\n      .limit(pagination.limit);\n    \n    const total = await FeeInvoice.countDocuments(query);\n    \n    return {\n      invoices,\n      total,\n      page: pagination.page,\n      limit: pagination.limit\n    };\n  } catch (error) {\n    throw new AppError(\'Failed to fetch invoices\', 500, \'FETCH_INVOICES_ERROR\');\n  }\n};\n\n/**\n * Get invoice by ID\n * @param {String} invoiceId - Invoice ID\n * @param {String} tenantId - Tenant ID\n * @returns {Object} Invoice\n */\nconst getInvoiceById = async (invoiceId, tenantId) => {\n  try {\n    const invoice = await FeeInvoice.findOne({ feeInvoiceId: invoiceId, tenantId });\n    \n    if (!invoice) {\n      throw new AppError(\'Invoice not found\', 404, \'INVOICE_NOT_FOUND\');\n    }\n    \n    return invoice;\n  } catch (error) {\n    if (error.name === \'CastError\') {\n      throw new AppError(\'Invalid invoice ID\', 400, \'INVALID_INVOICE_ID\');\n    }\n    throw error;\n  }\n};\n\n/**\n * Update invoice\n * @param {String} invoiceId - Invoice ID\n * @param {Object} updateData - Update data\n * @param {String} tenantId - Tenant ID\n * @returns {Object} Updated invoice\n */\nconst updateInvoice = async (invoiceId, updateData, tenantId) => {\n  try {\n    const invoice = await FeeInvoice.findOneAndUpdate(\n      { feeInvoiceId: invoiceId, tenantId },\n      updateData,\n      { new: true, runValidators: true }\n    );\n    \n    if (!invoice) {\n      throw new AppError(\'Invoice not found\', 404, \'INVOICE_NOT_FOUND\');\n    }\n    \n    return invoice;\n  } catch (error) {\n    if (error.name === \'CastError\') {\n      throw new AppError(\'Invalid invoice ID\', 400, \'INVALID_INVOICE_ID\');\n    }\n    throw error;\n  }\n};\n\n/**\n * Delete invoice (soft delete)\n * @param {String} invoiceId - Invoice ID\n * @param {String} tenantId - Tenant ID\n * @returns {Object} Deletion result\n */\nconst deleteInvoice = async (invoiceId, tenantId) => {\n  try {\n    const invoice = await FeeInvoice.findOneAndUpdate(\n      { feeInvoiceId: invoiceId, tenantId },\n      { isActive: false },\n      { new: true }\n    );\n    \n    if (!invoice) {\n      throw new AppError(\'Invoice not found\', 404, \'INVOICE_NOT_FOUND\');\n    }\n    \n    return {\n      message: \'Invoice deleted successfully\',\n      invoice\n    };\n  } catch (error) {\n    if (error.name === \'CastError\') {\n      throw new AppError(\'Invalid invoice ID\', 400, \'INVALID_INVOICE_ID\');\n    }\n    throw error;\n  }\n};\n\n/**\n * Get student invoices\n * @param {String} studentId - Student ID\n * @param {Object} filters - Additional filters\n * @param {Object} pagination - Pagination options\n * @param {String} tenantId - Tenant ID\n * @returns {Object} Student invoices and pagination info\n */\nconst getStudentInvoices = async (studentId, filters, pagination, tenantId) => {\n  try {\n    const query = { tenantId, studentId, ...filters };\n    \n    const invoices = await FeeInvoice.find(query)\n      .sort(pagination.sort || \'-dueDate\')\n      .skip(pagination.skip)\n      .limit(pagination.limit);\n    \n    const total = await FeeInvoice.countDocuments(query);\n    \n    return {\n      invoices,\n      total,\n      page: pagination.page,\n      limit: pagination.limit\n    };\n  } catch (error) {\n    throw new AppError(\'Failed to fetch student invoices\', 500, \'FETCH_STUDENT_INVOICES_ERROR\');\n  }\n};\n\n/**\n * Cancel invoice\n * @param {String} invoiceId - Invoice ID\n * @param {String} tenantId - Tenant ID\n * @param {String} reason - Cancellation reason\n * @returns {Object} Cancelled invoice\n */\nconst cancelInvoice = async (invoiceId, tenantId, reason) => {\n  try {\n    const invoice = await FeeInvoice.findOne({ feeInvoiceId: invoiceId, tenantId });\n    \n    if (!invoice) {\n      throw new AppError(\'Invoice not found\', 404, \'INVOICE_NOT_FOUND\');\n    }\n    \n    if (invoice.status === \'Paid\') {\n      throw new AppError(\'Cannot cancel paid invoice\', 400, \'CANNOT_CANCEL_PAID_INVOICE\');\n    }\n    \n    invoice.status = \'Cancelled\';\n    invoice.remarks = reason;\n    \n    await invoice.save();\n    \n    return invoice;\n  } catch (error) {\n    if (error.name === \'CastError\') {\n      throw new AppError(\'Invalid invoice ID\', 400, \'INVALID_INVOICE_ID\');\n    }\n    throw error;\n  }\n};\n\nmodule.exports = {\n  generateInvoice,\n  getInvoices,\n  getInvoiceById,\n  updateInvoice,\n  deleteInvoice,\n  getStudentInvoices,\n  cancelInvoice\n};\n</create-file>\n</function_calls>'}