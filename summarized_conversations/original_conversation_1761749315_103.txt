{'role': 'assistant', 'content': 'Let\'s continue creating more services:\n\n\n<function_calls>\n<create-file file_path="src/services/fees/paymentService.js">\nconst FeePayment = require(\'../../models/fees/FeePayment\');\nconst FeeInvoice = require(\'../../models/fees/FeeInvoice\');\nconst { AppError } = require(\'../../utils/helpers/errorHelper\');\n\n/**\n * Create a new fee payment\n * @param {Object} paymentData - Payment data\n * @param {String} tenantId - Tenant ID\n * @param {String} userId - User ID\n * @returns {Object} Created payment\n */\nconst createPayment = async (paymentData, tenantId, userId) => {\n  try {\n    // Add tenantId and receivedBy to payment data\n    paymentData.tenantId = tenantId;\n    paymentData.receivedBy = userId;\n    \n    // Create payment\n    const payment = new FeePayment(paymentData);\n    await payment.save();\n    \n    // Update invoice status if needed\n    if (paymentData.invoiceId) {\n      await updateInvoiceStatus(paymentData.invoiceId, tenantId);\n    }\n    \n    return payment;\n  } catch (error) {\n    if (error.code === 11000) {\n      throw new AppError(\'Payment with this transaction ID already exists\', 409, \'DUPLICATE_PAYMENT\');\n    }\n    throw error;\n  }\n};\n\n/**\n * Get payments with filters\n * @param {Object} filters - Filter criteria\n * @param {Object} pagination - Pagination options\n * @param {String} tenantId - Tenant ID\n * @returns {Object} Payments and pagination info\n */\nconst getPayments = async (filters, pagination, tenantId) => {\n  try {\n    const query = { tenantId, ...filters };\n    \n    // Handle student filter\n    if (filters.studentId) {\n      query.studentId = filters.studentId;\n    }\n    \n    // Handle date range filter\n    if (filters.startDate || filters.endDate) {\n      query.paymentDate = {};\n      if (filters.startDate) {\n        query.paymentDate.$gte = new Date(filters.startDate);\n      }\n      if (filters.endDate) {\n        query.paymentDate.$lte = new Date(filters.endDate);\n      }\n    }\n    \n    const payments = await FeePayment.find(query)\n      .sort(pagination.sort || \'-paymentDate\')\n      .skip(pagination.skip)\n      .limit(pagination.limit)\n      .populate(\'receivedBy\', \'name email\');\n    \n    const total = await FeePayment.countDocuments(query);\n    \n    return {\n      payments,\n      total,\n      page: pagination.page,\n      limit: pagination.limit\n    };\n  } catch (error) {\n    throw new AppError(\'Failed to fetch payments\', 500, \'FETCH_PAYMENTS_ERROR\');\n  }\n};\n\n/**\n * Get payment by ID\n * @param {String} paymentId - Payment ID\n * @param {String} tenantId - Tenant ID\n * @returns {Object} Payment\n */\nconst getPaymentById = async (paymentId, tenantId) => {\n  try {\n    const payment = await FeePayment.findOne({ feePaymentId: paymentId, tenantId })\n      .populate(\'receivedBy\', \'name email\');\n    \n    if (!payment) {\n      throw new AppError(\'Payment not found\', 404, \'PAYMENT_NOT_FOUND\');\n    }\n    \n    return payment;\n  } catch (error) {\n    if (error.name === \'CastError\') {\n      throw new AppError(\'Invalid payment ID\', 400, \'INVALID_PAYMENT_ID\');\n    }\n    throw error;\n  }\n};\n\n/**\n * Update payment\n * @param {String} paymentId - Payment ID\n * @param {Object} updateData - Update data\n * @param {String} tenantId - Tenant ID\n * @returns {Object} Updated payment\n */\nconst updatePayment = async (paymentId, updateData, tenantId) => {\n  try {\n    const payment = await FeePayment.findOneAndUpdate(\n      { feePaymentId: paymentId, tenantId },\n      updateData,\n      { new: true, runValidators: true }\n    );\n    \n    if (!payment) {\n      throw new AppError(\'Payment not found\', 404, \'PAYMENT_NOT_FOUND\');\n    }\n    \n    return payment;\n  } catch (error) {\n    if (error.name === \'CastError\') {\n      throw new AppError(\'Invalid payment ID\', 400, \'INVALID_PAYMENT_ID\');\n    }\n    throw error;\n  }\n};\n\n/**\n * Delete payment (soft delete)\n * @param {String} paymentId - Payment ID\n * @param {String} tenantId - Tenant ID\n * @returns {Object} Deletion result\n */\nconst deletePayment = async (paymentId, tenantId) => {\n  try {\n    const payment = await FeePayment.findOneAndUpdate(\n      { feePaymentId: paymentId, tenantId },\n   ...\n The full message content is stored at /workspace/summarized_conversations/original_conversation_1761749206_629.txt'}