{'role': 'assistant', 'content': '<function_calls>\n<create-file file_path="src/services/finance/journalService.js">\nconst JournalEntry = require(\'../../models/finance/JournalEntry\');\nconst Transaction = require(\'../../models/finance/Transaction\');\nconst Account = require(\'../../models/finance/Account\');\nconst { AppError } = require(\'../../utils/helpers/errorHelper\');\n\n/**\n * Create a new journal entry\n * @param {Object} journalData - Journal entry data\n * @param {String} tenantId - Tenant ID\n * @param {String} userId - User ID\n * @returns {Object} Created journal entry\n */\nconst createJournalEntry = async (journalData, tenantId, userId) => {\n  try {\n    // Add tenantId and createdBy to journal data\n    journalData.tenantId = tenantId;\n    journalData.createdBy = userId;\n    \n    // Validate that total debit equals total credit\n    const totalDebit = journalData.lineItems.reduce((sum, item) => sum + (item.debit || 0), 0);\n    const totalCredit = journalData.lineItems.reduce((sum, item) => sum + (item.credit || 0), 0);\n    \n    if (totalDebit !== totalCredit) {\n      throw new AppError(\'Total debit must equal total credit\', 400, \'INVALID_JOURNAL_ENTRY\');\n    }\n    \n    // Set totals\n    journalData.totalDebit = totalDebit;\n    journalData.totalCredit = totalCredit;\n    \n    // Create journal entry\n    const journalEntry = new JournalEntry(journalData);\n    await journalEntry.save();\n    \n    return journalEntry;\n  } catch (error) {\n    if (error.code === 11000) {\n      throw new AppError(\'Journal entry with this number already exists\', 409, \'DUPLICATE_JOURNAL_NUMBER\');\n    }\n    throw error;\n  }\n};\n\n/**\n * Get journal entries with filters\n * @param {Object} filters - Filter criteria\n * @param {Object} pagination - Pagination options\n * @param {String} tenantId - Tenant ID\n * @returns {Object} Journal entries and pagination info\n */\nconst getJournalEntries = async (filters, pagination, tenantId) => {\n  try {\n    const query = { tenantId, ...filters };\n    \n    // Handle date range filter\n    if (filters.startDate || filters.endDate) {\n      query.entryDate = {};\n      if (filters.startDate) {\n        query.entryDate.$gte = new Date(filters.startDate);\n      }\n      if (filters.endDate) {\n        query.entryDate.$lte = new Date(filters.endDate);\n      }\n    }\n    \n    const journalEntries = await JournalEntry.find(query)\n      .sort(pagination.sort || \'-entryDate\')\n      .skip(pagination.skip)\n      .limit(pagination.limit)\n      .populate(\'lineItems.accountId\', \'accountCode accountName\')\n      .populate(\'createdBy\', \'name email\');\n    \n    const total = await JournalEntry.countDocuments(query);\n    \n    return {\n      journalEntries,\n      total,\n      page: pagination.page,\n      limit: pagination.limit\n    };\n  } catch (error) {\n    throw new AppError(\'Failed to fetch journal entries\', 500, \'FETCH_JOURNAL_ENTRIES_ERROR\');\n  }\n};\n\n/**\n * Get journal entry by ID\n * @param {String} entryId - Journal entry ID\n * @param {String} tenantId - Tenant ID\n * @returns {Object} Journal entry\n */\nconst getJournalEntryById = async (entryId, tenantId) => {\n  try {\n    const journalEntry = await JournalEntry.findOne({ journalEntryId: entryId, tenantId })\n      .populate(\'lineItems.accountId\', \'accountCode accountName\')\n      .populate(\'createdBy\', \'name email\')\n      .populate(\'approvedBy\', \'name email\')\n      .populate(\'postedBy\', \'name email\');\n    \n    if (!journalEntry) {\n      throw new AppError(\'Journal entry not found\', 404, \'JOURNAL_ENTRY_NOT_FOUND\');\n    }\n    \n    return journalEntry;\n  } catch (error) {\n    if (error.name === \'CastError\') {\n      throw new AppError(\'Invalid journal entry ID\', 400, \'INVALID_JOURNAL_ENTRY_ID\');\n    }\n    throw error;\n  }\n};\n\n/**\n * Update journal entry\n * @param {String} entryId - Journal entry ID\n * @param {Object} updateData - Update data\n * @param {String} tenantId - Tenant ID\n * @returns {Object} Updated journal entry\n */\nconst updateJournalEntry = async (entryId, updateData, tenantId) => {\n  try {\n    // Prevent updating posted entries\n    const existingEntry = await JournalEntry.findOne({ journalEntryId: entryId, tenantId });\n    \n    if (!existingEntry) {\n      throw new AppError(\'Journal entry not found\', 404, \'JOURNAL_ENTRY_NOT_FOUND\');\n    }\n    \n    if (existingEntry.status === \'Posted\') {\n      throw new AppError(\'Cannot update posted journal entries\', 400, \'CANNOT_UPDATE_POSTED_ENTRY\');\n    }\n    \n    // Validate debit/credit balance if line items are being updated\n    if (updateData.lineItems) {\n      const totalDebit = updateData.lineItems.reduce((sum, item) => sum + (item.debit || 0), 0);\n      const totalCredit = updateData.lineItems.reduce((sum, item) => sum + (item.credit || 0), 0);\n      \n      if (totalDebit !== totalCredit) {\n        throw new AppError(\'Total debit must equal total credit\', 400, \'INVALID_JOURNAL_ENTRY\');\n      }\n      \n      updateData.totalDebit = totalDebit;\n      updateData.totalCredit = totalCredit;\n    }\n    \n    const journalEntry = await JournalEntry.findOneAndUpdate(\n      { journalEntryId: entryId, tenantId },\n      updateData,\n      { new: true, runValidators: true }\n    );\n    \n    return journalEntry;\n  } catch (error) {\n    if (error.name === \'CastError\') {\n      throw new AppError(\'Invalid journal entry ID\', 400, \'INVALID_JOURNAL_ENTRY_ID\');\n    }\n    throw error;\n  }\n};\n\n/**\n * Post journal entry\n * @param {String} entryId - Journal entry ID\n * @param {String} tenantId - Tenant ID\n * @param {String} userId - User ID\n * @returns {Object} Posted journal entry\n */\nconst postJournalEntry = async (entryId, tenantId, userId) => {\n  try {\n    // Get journal entry\n    const journalEntry = await JournalEntry.findOne({ journalEntryId: entryId, tenantId });\n    \n    if (!journalEntry) {\n      throw new AppError(\'Journal entry not found\', 404, \'JOURNAL_ENTRY_NOT_FOUND\');\n    }\n    \n    if (journalEntry.status === \'Posted\') {\n      throw new AppError(\'Journal entry is already posted\', 400, \'ENTRY_ALREADY_POSTED\');\n    }\n    \n    // Validate that total debit equals total credit\n    if (journalEntry.totalDebit !== journalEntry.totalCredit) {\n      throw new AppError(\'Total debit must equal total credit\', 400, \'INVALID_JOURNAL_ENTRY\');\n    }\n    \n    // Create transactions for each line item\n    const transactions = [];\n    \n    for (const lineItem of journalEntry.lineItems) {\n      // Verify account exists and is active\n      const account = await Account.findOne({ accountId: lineItem.accountId, tenantId, isActive: true });\n      \n      if (!account) {\n        throw new AppError(`Account not found or inactive: ${lineItem.accountId}`, 400, \'INVALID_ACCOUNT\');\n      }\n      \n      // Create transaction\n      const transaction = new Transaction({\n        tenantId,\n        accountId: lineItem.accountId,\n        journalEntryId: journalEntry.journalEntryId,\n        transactionDate: journalEntry.entryDate,\n        transactionType: lineItem.debit > 0 ? \'Debit\' : \'Credit\',\n        amount: lineItem.debit > 0 ? lineItem.debit : lineItem.credit,\n        description: lineItem.description || journalEntry.description,\n        referenceId: journalEntry.journalEntryId,\n        referenceType: \'JournalEntry\'\n      });\n      \n      transactions.push(transaction);\n    }\n    \n    // Save all transactions\n    await Transaction.insertMany(transactions);\n    \n    // Update journal entry status\n    journalEntry.status = \'Posted\';\n    journalEntry.postedDate = new Date();\n    journalEntry.postedBy = userId;\n    await journalEntry.save();\n    \n    return journalEntry;\n  } catch (error) {\n    if (error.name === \'CastError\') {\n      throw new AppError(\'Invalid journal entry ID\', 400, \'INVALID_JOURNAL_ENTRY_ID\');\n    }\n    throw error;\n  }\n};\n\n/**\n * Reverse journal entry\n * @param {String} entryId - Journal entry ID\n * @param {String} tenantId - Tenant ID\n * @param {String} userId - User ID\n * @param {Object} reversalData - Reversal data\n * @returns {Object} Reversed journal entry\n */\nconst reverseJournalEntry = async (entryId, tenantId, userId, reversalData) => {\n  try {\n    // Get original journal entry\n    const originalEntry = await JournalEntry.findOne({ journalEntryId: entryId, tenantId });\n    \n    if (!originalEntry) {\n      throw new AppError(\'Journal entry not found\', 404, \'JOURNAL_ENTRY_NOT_FOUND\');\n    }\n    \n    if (originalEntry.status !== \'Posted\') {\n      throw new AppError(\'Only posted journal entries can be reversed\', 400, \'ENTRY_NOT_POSTED\');\n    }\n    \n    // Create reversal entry\n    const reversalEntryData = {\n      entryNumber: `REV-${originalEntry.entryNumber}`,\n      entryDate: reversalData.reversalDate,\n      entryType: originalEntry.entryType,\n      referenceNumber: originalEntry.entryNumber,\n      description: `Reversal of ${originalEntry.description || originalEntry.entryNumber}`,\n      lineItems: originalEntry.lineItems.map(item => ({\n        accountId: item.accountId,\n        debit: item.credit, // Swap debit and credit\n        credit: item.debit,\n        description: `Reversal: ${item.description || \'\'}`\n      })),\n      totalDebit: originalEntry.totalCredit,\n      totalCredit: originalEntry.totalDebit,\n      createdBy: userId,\n      approvalRequired: false,\n      status: \'Posted\'\n    };\n    \n    // Create reversal journal entry\n    const reversalEntry = new JournalEntry({\n      ...reversalEntryData,\n      tenantId\n    });\n    \n    await reversalEntry.save();\n    \n    // Create reversal transactions\n    const transactions = [];\n    \n    for (const lineItem of reversalEntry.lineItems) {\n      const transaction = new Transaction({\n        tenantId,\n        accountId: lineItem.accountId,\n        journalEntryId: reversalEntry.journalEntryId,\n        transactionDate: reversalEntry.entryDate,\n        transactionType: lineItem.debit > 0 ? \'Debit\' : \'Credit\',\n        amount: lineItem.debit > 0 ? lineItem.debit : lineItem.credit,\n        description: lineItem.description || reversalEntry.description,\n        referenceId: reversalEntry.journalEntryId,\n        referenceType: \'ReversalEntry\'\n      });\n      \n      transactions.push(transaction);\n    }\n    \n    // Save all transactions\n    await Transaction.insertMany(transactions);\n    \n    // Update original entry\n    originalEntry.status = \'Reversed\';\n    originalEntry.reversalDate = reversalData.reversalDate;\n    originalEntry.reversalReason = reversalData.reason;\n    originalEntry.reversedBy = userId;\n    await originalEntry.save();\n    \n    return {\n      originalEntry,\n      reversalEntry\n    };\n  } catch (error) {\n    if (error.name === \'CastError\') {\n      throw new AppError(\'Invalid journal entry ID\', 400, \'INVALID_JOURNAL_ENTRY_ID\');\n    }\n    throw error;\n  }\n};\n\nmodule.exports = {\n  createJournalEntry,\n  getJournalEntries,\n  getJournalEntryById,\n  updateJournalEntry,\n  postJournalEntry,\n  reverseJournalEntry\n};\n</create-file>\n</function_calls>'}