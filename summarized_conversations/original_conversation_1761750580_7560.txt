{'role': 'assistant', 'content': '<function_calls>\n<create-file file_path="src/services/finance/journalService.js">\nconst JournalEntry = require(\'../../models/finance/JournalEntry\');\nconst Transaction = require(\'../../models/finance/Transaction\');\nconst Account = require(\'../../models/finance/Account\');\nconst { AppError } = require(\'../../utils/helpers/errorHelper\');\n\n/**\n * Create a new journal entry\n * @param {Object} journalData - Journal entry data\n * @param {String} tenantId - Tenant ID\n * @param {String} userId - User ID\n * @returns {Object} Created journal entry\n */\nconst createJournalEntry = async (journalData, tenantId, userId) => {\n  try {\n    // Add tenantId and createdBy to journal data\n    journalData.tenantId = tenantId;\n    journalData.createdBy = userId;\n    \n    // Validate that total debit equals total credit\n    const totalDebit = journalData.lineItems.reduce((sum, item) => sum + (item.debit || 0), 0);\n    const totalCredit = journalData.lineItems.reduce((sum, item) => sum + (item.credit || 0), 0);\n    \n    if (totalDebit !== totalCredit) {\n      throw new AppError(\'Total debit must equal total credit\', 400, \'INVALID_JOURNAL_ENTRY\');\n    }\n    \n    // Set totals\n    journalData.totalDebit = totalDebit;\n    journalData.totalCredit = totalCredit;\n    \n    // Create journal entry\n    const journalEntry = new JournalEntry(journalData);\n    await journalEntry.save();\n    \n    return journalEntry;\n  } catch (error) {\n    if (error.code === 11000) {\n      throw new AppError(\'Journal entry with this number already exists\', 409, \'DUPLICATE_JOURNAL_NUMBER\');\n    }\n    throw error;\n  }\n};\n\n/**\n * Get journal entries with filters\n * @param {Object} filters - Filter criteria\n * @param {Object} pagination - Pagination options\n * @param {String} tenantId - Tenant ID\n * @returns {Object} Journal entries and pagination info\n */\nconst getJournalEntries = async (filters, pagination, tenantId) => {\n  try {\n    const query = { tenantId, ...filters };\n    \n    // Handle date range filter\n    if (filters.startDate || filters.endDate) {\n      query.entryDate = {};\n      if (filters.startDate) {\n        query.entryDate.$gte = new Date(filters.startDate);\n      }\n      if (filters.endDate) {\n        query.entryDate.$lte = new Date(filters.endDate);\n      }\n    }\n    \n    const journalEntries = await JournalEntry.find(query)\n      .sort(pagination.sort || \'-entryDate\')\n      .skip(pagination.skip)\n      .limit(pagination.limit)\n      .populate(\'lineItems.accountId\', \'accountCode accountName\')\n      .populate(\'createdBy\', \'name email\');\n    \n    const total = await JournalEntry.countDocuments(query);\n    \n    return {\n      journalEntries,\n      total,\n      page: pagination.page,\n      limit: pagination.limit\n    };\n  } catch (error) {\n    throw new AppError(\'Failed to fetch journal entries\', 500, \'FETCH_JOURNAL_ENTRIES_ERROR\');\n  }\n};\n\n/**\n * Get journal entry by ID\n * @param {String} entryId - Journal entry ID\n * @param {String} tenantId - Tenant ID\n * @returns {Object} Journal entry\n */\nconst getJournalEntryById = async (entryId, tenantId) => {\n  try {\n    const journalEntry = await JournalEntry.findOne({ journalEntryId: entryId, tenantId })\n      .populate(\'lineItems.accountId\', \'accountCode accountName\')\n      .populate(\'createdBy\', \'name email\')\n      .populate(\'approvedBy\', \'name email\')\n      .populate(\'postedBy\', \'name email\');\n    \n    if (!journalEntry) {\n      throw new AppError(\'Journal entry not found\', 404, \'JOURNAL_ENTRY_NOT_FOUND\');\n    }\n    \n    return journalEntry;\n  } catch (error) {\n    if (error.name === \'CastError\') {\n      throw new AppError(\'Invalid journal entry ID\', 400, \'INVALID_JOURNAL_ENTRY_ID\');\n    }\n    throw error;\n  }\n};\n\n/**\n * Update journal entry\n * @param {String} entryId - Journal entry ID\n * @param {Object} updateData - Update data\n * @param {String} tenantId - Tenant ID\n * @returns {Object} Updated journal entry\n */\nconst updateJournalEntry = async (entryId, updateData, tenantId) => {\n  try {\n    // Prevent updating posted entries\n    const existingEntry = await JournalEntry.findOne({ journalEntryId: entryId, tenantId }...\n The full message content is stored at /workspace/summarized_conversations/original_conversation_1761750371_6008.txt'}